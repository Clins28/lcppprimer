# 1. 类的基础
-----------

![](pics/_1527651533_28213.png)

## 1.1. 定义一个简单的类（抽象数据类型）
### 1.1.1. 定义类的成员函数
#### 1.1.1.1. 构造函数
构造函数定义了类的对象被初始化的方式，构造函数是特殊的成员函数：
* 构造函数没有返回类型，函数名与类名一致
* 构造函数不能被声明为const
>当我们创建类的一个const对象时，直到构造函数完成初始化的过程，对象才真正取得其“常量”属性，因此，构造函数在const对象的构建过程中可以向其写值。

构造函数可以有一下几种写法：
```cpp
class Sales_data
{
public:
	//构造函数
	Sales_data() = default;                                    //默认构造函数
	Sales_data(const std::string &s):bookNo(s){}               //构造函数初始值列表
	Sales_data(std::istream &);                                //类的外部定义构造函数
	Sales_data(const std::string &s, unsigned n, double p);    //类的外部显式赋值
}

Sales_data::Sales_data(std::istream &is)
{
	read(is, *this);
}

Sales_data::Sales_data(const std::string &s, unsigned n, double p)
{
	this->bookNo = s;
	this->units_sold = n;
	this->revenue = n * p;

}
```
#### 1.1.1.2. 静态成员函数

```cpp
	string Getname() const { return name; }		// const在参数传递中的作用 https://blog.csdn.net/zheng19880607/article/details/23883437
	string Getadress() const { return adress; }	// 声明为const成员变量可以保证不会修改数据成员
```
#### 1.1.1.3. 赋值函数
函数的返回值作为引用传递
>*引自P247<br>
>返回引用的函数是左值的，意味着这些函数返回的是对象本身而非副本。如果我们把一系列操作连接在一条表达式中的话这些操作将在同一个对象上执行*
>```cpp
>myScreen.move(4,0).set('#');
>```
>假如定义的返回类型不是引用，则move的返回值将是*this的书本，set只能改变临时副本，而不能改变myScreen的值。
>```cpp
>Screen temp = myScreen.move(4,0);
>temp.set('#');
>```
<br>

```cpp
Sales_data& Sales_data::combine(const Sales_data &rhs)	//函数返回左值
{
	units_sold += rhs.units_sold;
	revenue += rhs.revenue;
	return *this;										//返回一个 this 指针的解引用，即执行该函数的对象
}
```

### 1.1.2. this指针
this指针代表指向该类的实例的指针，\*this代表该类的实例<br>
this-> member 与 （*this).member 相等

## 1.2. 封装类的数据
### 1.2.1. 使用private来封装
 使用private封装类的内部实现，所有非类的成员都无法访问private成员<br>
 修改private成员时无需考虑客户代码，只需保证最终类的接口不改变即可
 
### 1.2.2. 友元
 友元必须声明在类的内部，除此之外在类的外部也需要有函数声明<br>
 格式形如`friend ostream &print(ostream&, const Person&);`
 